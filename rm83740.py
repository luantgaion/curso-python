# -*- coding: utf-8 -*-
"""RM83740.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DaHA2AwOZLPw3Bc4P_tMWZeJ7lAuR-Ak
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import cv2
from matplotlib import pyplot as plt
import numpy as np

# le a imagem
img = cv2.imread("circulo.png")

# converte a imagem do espaço de cor BGR para HSV
img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

# define os limites inferior e superior da faixa de cor desejada na imagem HSV
lower_color_hsv = np.array([0,166,177])
upper_color_hsv = np.array([86,239,226])

# cria uma mascara binaria com os pixels na faixa de cor desejada na imagem HSV
mask_hsv = cv2.inRange(img_hsv, lower_color_hsv, upper_color_hsv)

# encontra os contornos na mascara binaria
contours,_ = cv2.findContours(mask_hsv, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# converte a mascara binaria do espaço de cor grayscale para RGB
mask_rgb = cv2.cvtColor(mask_hsv, cv2.COLOR_GRAY2RGB)

# desenha os contornos encontrados na mascara RGB
cv2.drawContours(mask_rgb, contours, -1, [150, 150, 150], 5);

# cria uma copia da mascara RGB com os contornos desenhados
contours_rgb = mask_rgb.copy()

# exibe a imagem com os contornos desenhados
plt.imshow(cv2.cvtColor(contours_rgb, cv2.COLOR_BGR2RGB))
plt.show()

# verifica se há pelo menos 2 contornos
if len(contours) >= 2:

# ordena os contornos pelo tamanho da area, do maior para o menor
    contours = sorted(contours, key=cv2.contourArea, reverse=True)

# seleciona os dois contornos maiores
    cnt1 = contours[0]
    cnt2 = contours[1]

# calcula os momentos dos dois contornos selecionados e encontra o centro de cada um
    M1 = cv2.moments(cnt1)
    M2 = cv2.moments(cnt2)
    center1 = (int(M1["m10"] / M1["m00"]), int(M1["m01"] / M1["m00"]))
    center2 = (int(M2["m10"] / M2["m00"]), int(M2["m01"] / M2["m00"]))

# encontra o indice do contorno com a maior area
    value1 = 0
    index1 = 0
    for y in range(0, (len(contours))):
        if (cv2.contourArea(contours[y])) > value1:
            value1 = cv2.contourArea(contours[y])
            index1 = y

# encontra o indice do contorno com a segunda maior area
    value2 = 0
    index2 = 0
    for y in range(0, (len(contours))):
        if (cv2.contourArea(contours[y])) > value2 and cv2.contourArea(contours[y]) < value1:
           value2 = cv2.contourArea(contours[y])
           index2 = y

# encontra o centro dos dois contornos maiores
    cx1 = int(M1['m10']/M1['m00'])
    cy1 = int(M1['m01']/M1['m00'])
    cx2 = int(M2['m10']/M2['m00'])
    cy2 = int(M2['m01']/M2['m00'])

# define o tamanho das linhas que serão desenhadas
    size = 20

# desenha linhas horizontais e verticais nos centros dos contornos maiores
    cv2.line(contours_rgb,(cx1 - size,cy1),(cx1 + size,cy1),(0, 0, 0),5)
    cv2.line(contours_rgb,(cx1,cy1 - size),(cx1, cy1 + size),(0, 0, 0),5)
    cv2.line(contours_rgb,(cx2 - size,cy2),(cx2 + size,cy2),(0, 0, 0),5)
    cv2.line(contours_rgb,(cx2,cy2 - size),(cx2, cy2 + size),(0, 0, 0),5)

# cria as strings que serão exibidas com as informações dos contornos
    text1 = cy1 , cx1,  value2
    text2 = cy2 , cx2, value1

# define a pisiçao inicial das strings na imagem
    origem1 = (200, 500)
    origem2 = (200, 50)

# insere os texto na imagem
    cv2.putText(contours_rgb, str(text1), origem1, cv2.FONT_HERSHEY_SIMPLEX,1,(255,255,255),2,cv2.LINE_AA)
    cv2.putText(contours_rgb, str(text2), origem2, cv2.FONT_HERSHEY_SIMPLEX,1,(255,255,255),2,cv2.LINE_AA)

# escreve as informações dos contornos na imagem
plt.imshow(cv2.cvtColor(contours_rgb, cv2.COLOR_BGR2RGB))
plt.show()

import math

# desenha uma linha na imagem contours_rgb, indo das coordenadas (108, 133) até (612, 399), com a cor (150, 150, 150) e a espessura 5
cv2.line(contours_rgb, (108,133), (612, 399), (150, 150, 150), 5)

# calcula as diferenças entre as coordenadas iniciais e finais da linha desenhada
rx = 612 - 108
ry = 399 - 133

# calcula o angulo em radianos entre as duas coordenadas usando a função atan2 da biblioteca math
angle = math.atan2(ry, rx)

# converte o angulo para graus
degrees = math.degrees(angle)

# exibe a imagem com a linha desenhada
plt.imshow(cv2.cvtColor(contours_rgb, cv2.COLOR_BGR2RGB))
plt.show

# exibe o angulo em graus com 2 casas decimais
print("angulo: {:.2f}°".format(degrees))
